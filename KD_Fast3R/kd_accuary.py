# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_A-RRtb3E5475fPvJzQK3jcZd7j1Lqlq
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import torch
from scipy.spatial.distance import cdist
from sklearn.metrics import mean_absolute_error
from skimage.metrics import structural_similarity as ssim
import matplotlib.pyplot as plt
from typing import Dict, Tuple, Union, List
import warnings
import os
import random

class Evaluator:
    def __init__(self, student_path, teacher_path="/content/drive/MyDrive/ex_teacher_output.pt"):
        self.teacher_pointmap = self.load_teacher_pointmap_from_pt(teacher_path)
        self.student_pointmap = self.load_student_pointmap_from_pth(student_path)

    def load_teacher_pointmap_from_pt(self, teacher_path: str, index: int = 0):
        teacher_data = torch.load(teacher_path, map_location=torch.device('cpu'))
        teacher_pointmap = dict()
        t_preds = teacher_data['preds']
        for i, v in enumerate(t_preds[0]['pts3d_in_other_view'].reshape(-1, 3)):
            teacher_pointmap[i] = v
        return teacher_pointmap

    def load_student_pointmap_from_pth(self, student_path: str, index: int = 0):
        student_data = torch.load(student_path, map_location=torch.device('cpu'))
        student_pointmap = dict()
        s_preds = student_data['512']['preds']
        for i, v in enumerate(s_preds[0]['pts3d_in_other_view'].reshape(-1, 3)):
            student_pointmap[i] = v
        return student_pointmap

    def chamber_distance(self, use_squared: bool = True, max_points=1000):
        """
        Chamfer Distance ê³„ì‚° (point ìˆ˜ ì œí•œí•˜ì—¬ ì•ˆì •ì ìœ¼ë¡œ ìˆ˜í–‰)
        """
        def subsample_points(pointmap, max_points):
            keys = list(pointmap.keys())
            sampled_keys = random.sample(keys, min(len(keys), max_points))
            return np.array([pointmap[k] for k in sampled_keys])

        # ìƒ˜í”Œë§í•˜ì—¬ point ìˆ˜ ì œí•œ
        teacher_points = subsample_points(self.teacher_pointmap, max_points)
        student_points = subsample_points(self.student_pointmap, max_points)

        # ê±°ë¦¬ ê³„ì‚°
        dist_gt_to_pred = cdist(teacher_points, student_points, metric='euclidean')
        min_dist_gt_to_pred = np.min(dist_gt_to_pred, axis=1)

        dist_pred_to_gt = cdist(student_points, teacher_points, metric='euclidean')
        min_dist_pred_to_gt = np.min(dist_pred_to_gt, axis=1)

        if use_squared:
            min_dist_gt_to_pred **= 2
            min_dist_pred_to_gt **= 2

        cd_gt_to_pred = np.mean(min_dist_gt_to_pred)
        cd_pred_to_gt = np.mean(min_dist_pred_to_gt)
        chamber_distance = cd_gt_to_pred + cd_pred_to_gt

        results = {
        'chamber_distance': float(chamber_distance),
        'cd_gt_to_pred': float(cd_gt_to_pred),
        'cd_pred_to_gt': float(cd_pred_to_gt),
        'num_gt_points': len(teacher_points),
        'num_pred_points': len(student_points),
        'distance_type': 'squared' if use_squared else 'euclidean'
        }

        return results

    '''
    def chamber_distance(self, use_squared: bool = True):
        """
        1. Chamber Distance (ì „ì²´ point cloud ê°„ ìœ ì‚¬ë„)

        ë‘ point cloud ê°„ì˜ êµ¬ì¡°ì  ìœ ì‚¬ì„±ì„ ì¸¡ì •í•©ë‹ˆë‹¤.
        ê° ì ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì ê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ì–‘ë°©í–¥ìœ¼ë¡œ ê³„ì‚°í•©ë‹ˆë‹¤.

        ê³µì‹: CD(P,Q) = (1/|P|) * Î£ min||p-q||Â² + (1/|Q|) * Î£ min||q-p||Â²

        """
        teacher_pointmap = np.array(list(self.teacher_pointmap.values()))
        student_pointmap = np.array(list(self.student_pointmap.values()))

        # GTì—ì„œ Predë¡œì˜ ê±°ë¦¬ (ê° GT ì ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ Pred ì ê¹Œì§€ì˜ ê±°ë¦¬)
        dist_gt_to_pred = cdist(teacher_pointmap, student_pointmap, metric='euclidean')
        min_dist_gt_to_pred = np.min(dist_gt_to_pred, axis=1)

        # Predì—ì„œ GTë¡œì˜ ê±°ë¦¬ (ê° Pred ì ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ GT ì ê¹Œì§€ì˜ ê±°ë¦¬)
        dist_pred_to_gt = cdist(student_pointmap, teacher_pointmap, metric='euclidean')
        min_dist_pred_to_gt = np.min(dist_pred_to_gt, axis=1)

        if use_squared:
            min_dist_gt_to_pred = min_dist_gt_to_pred ** 2
            min_dist_pred_to_gt = min_dist_pred_to_gt ** 2

        # Chamber Distance ê³„ì‚°
        cd_gt_to_pred = np.mean(min_dist_gt_to_pred)
        cd_pred_to_gt = np.mean(min_dist_pred_to_gt)
        chamber_distance = cd_gt_to_pred + cd_pred_to_gt

        results = {
            'chamber_distance': float(chamber_distance),
            'cd_gt_to_pred': float(cd_gt_to_pred),
            'cd_pred_to_gt': float(cd_pred_to_gt),
            'num_gt_points': len(teacher_pointmap),
            'num_pred_points': len(student_pointmap),
            'distance_type': 'squared' if use_squared else 'euclidean'
        }

        return results
    '''

    def pointwise_l2_distance(self):
        """
        2. Point-wise L2 Distance (index ì •í™•ë„)

        Chamber Distanceì™€ ë™ì¼í•˜ì§€ë§Œ ëª…ì‹œì ìœ¼ë¡œ ë¶„ë¦¬í•˜ì—¬ êµ¬í˜„.
        ê° ëŒ€ì‘ë˜ëŠ” í¬ì¸íŠ¸ ê°„ì˜ ì§ì ‘ì ì¸ ê±°ë¦¬ë¥¼ ì¸¡ì •í•©ë‹ˆë‹¤.

        """
        # ê³µí†µ indexë§Œ ì‚¬ìš© (ë‘ pointmapì— ëª¨ë‘ ì¡´ì¬í•˜ëŠ” index)
        common_indices = set(self.teacher_pointmap.keys()) & set(self.student_pointmap.keys())

        # ê³µí†µ indexì— ëŒ€í•´ì„œë§Œ ì¢Œí‘œ ì¶”ì¶œ
        gt_coords = np.array([self.teacher_pointmap[idx] for idx in sorted(common_indices)])
        pred_coords = np.array([self.student_pointmap[idx] for idx in sorted(common_indices)])

        # ê° í¬ì¸íŠ¸ë³„ L2 ê±°ë¦¬ ê³„ì‚°
        l2_distances = np.sqrt(np.sum((gt_coords - pred_coords) ** 2, axis=1))

        results = {
            'mean_l2_distance': float(np.mean(l2_distances)),
            'std_l2_distance': float(np.std(l2_distances)),
            'min_l2_distance': float(np.min(l2_distances)),
            'max_l2_distance': float(np.max(l2_distances)),
            'median_l2_distance': float(np.median(l2_distances))
        }

        return results

    def per_axis_mae(self):
        """
        3. Per-axis MAE (ê° ì¶•ë³„ ì •í™•ë„)

        X, Y, Z ì¶•ë³„ë¡œ Mean Absolute Errorë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        ì–´ëŠ ì¶•ì—ì„œ ë” í° ì˜¤ì°¨ê°€ ë°œìƒí•˜ëŠ”ì§€ ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

        ê³µì‹: MAE_x = (1/N) * Î£ |xi - xÌ‚i|

        """
        # ê³µí†µ index ì°¾ê¸°
        common_indices = set(self.teacher_pointmap.keys()) & set(self.student_pointmap.keys())

        # ì¢Œí‘œ ì¶”ì¶œ ë° ì¶•ë³„ ë¶„ë¦¬
        gt_coords = np.array([self.teacher_pointmap[idx] for idx in sorted(common_indices)])
        pred_coords = np.array([self.student_pointmap[idx] for idx in sorted(common_indices)])

        # ê° ì¶•ë³„ MAE ê³„ì‚°
        mae_x = np.mean(np.abs(gt_coords[:, 0] - pred_coords[:, 0]))
        mae_y = np.mean(np.abs(gt_coords[:, 1] - pred_coords[:, 1]))
        mae_z = np.mean(np.abs(gt_coords[:, 2] - pred_coords[:, 2]))

        # ì „ì²´ MAE (3D ê³µê°„ì—ì„œì˜ í‰ê·  ì ˆëŒ€ ì˜¤ì°¨)
        overall_mae = np.mean(np.abs(gt_coords - pred_coords))

        results = {
            'mae_x': float(mae_x),
            'mae_y': float(mae_y),
            'mae_z': float(mae_z),
            'overall_mae': float(overall_mae),
            'max_axis_mae': float(max(mae_x, mae_y, mae_z)),
            'min_axis_mae': float(min(mae_x, mae_y, mae_z)),
            'num_points': len(common_indices)
        }

        return results

    def self_consistency_check(self, neighbor_threshold: float = 0.1, max_points: int = 5000):
        pred_coords = np.array(list(self.student_pointmap.values()))

        # ë„ˆë¬´ ë§ì€ ì  ìƒ˜í”Œë§
        if len(pred_coords) > max_points:
            indices = np.random.choice(len(pred_coords), max_points, replace=False)
            pred_coords = pred_coords[indices]

        if len(pred_coords) < 2:
            return {'self_consistency_score': 1.0, 'num_outliers': 0}

        from scipy.spatial import KDTree
        tree = KDTree(pred_coords)
        neighbors_count = np.array([len(tree.query_ball_point(p, neighbor_threshold)) - 1 for p in pred_coords])

        mean_neighbors = np.mean(neighbors_count)
        std_neighbors = np.std(neighbors_count)
        outlier_threshold = max(1, mean_neighbors - 2 * std_neighbors)
        outliers = np.sum(neighbors_count < outlier_threshold)

        consistency_score = 1.0 - (outliers / len(pred_coords))

        results = {
            'self_consistency_score': float(consistency_score),
            'num_outliers': int(outliers),
            'mean_neighbors': float(mean_neighbors),
            'std_neighbors': float(std_neighbors),
            'total_points': len(pred_coords)
        }

        return results

    '''
    def self_consistency_check(self, neighbor_threshold: float = 0.1):
        """
        4. Self-consistency (ì˜ˆì¸¡ì˜ ë‚´ë¶€ ì¼ê´€ì„±)

        ì˜ˆì¸¡ëœ point cloud ë‚´ì—ì„œ ì´ì›ƒ ì ë“¤ ê°„ì˜ ì¼ê´€ì„±ì„ ì²´í¬í•©ë‹ˆë‹¤.
        ê¸‰ê²©í•œ ë³€í™”ë‚˜ outlierë¥¼ ê°ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

        """
        pred_coords = np.array(list(self.student_pointmap.values()))

        if len(pred_coords) < 2:
            return {'self_consistency_score': 1.0, 'num_outliers': 0}

        # ê° ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì ê¹Œì§€ì˜ ê±°ë¦¬ ê³„ì‚°
        distances = cdist(pred_coords, pred_coords, metric='euclidean')

        # ê° ì ì˜ ì´ì›ƒ ìˆ˜ ê³„ì‚° (ìê¸° ìì‹  ì œì™¸)
        neighbors_count = np.sum(distances < neighbor_threshold, axis=1) - 1

        # ì´ì›ƒì´ ì ì€ ì ë“¤ì„ outlierë¡œ ê°„ì£¼
        mean_neighbors = np.mean(neighbors_count)
        std_neighbors = np.std(neighbors_count)
        outlier_threshold = max(1, mean_neighbors - 2 * std_neighbors)
        outliers = np.sum(neighbors_count < outlier_threshold)

        # ì „ì²´ì ì¸ density ì¼ê´€ì„± ê³„ì‚°
        consistency_score = 1.0 - (outliers / len(pred_coords))

        results = {
            'self_consistency_score': float(consistency_score),
            'num_outliers': int(outliers),
            'mean_neighbors': float(mean_neighbors),
            'std_neighbors': float(std_neighbors),
            'total_points': len(pred_coords)
        }

        return results
    '''

    def compute_ssim_3d(self, grid_size: int = 32):
        """
        5. 3D SSIM (êµ¬ì¡°ì  ìœ ì‚¬ì„±)

        3D point cloudë¥¼ 3D gridë¡œ voxelizeí•œ í›„ SSIMì„ ê³„ì‚°í•©ë‹ˆë‹¤.
        êµ¬ì¡°ì  íŒ¨í„´ì˜ ìœ ì‚¬ì„±ì„ ì¸¡ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

        Args:
            gt_pointmap: Teacher ëª¨ë¸ ì¶œë ¥ (Ground Truth)
            pred_pointmap: Student ëª¨ë¸ ì¶œë ¥ (ì˜ˆì¸¡ê°’)
            grid_size: Voxel gridì˜ í¬ê¸°

        Returns:
            float: 3D SSIM ê°’ (0~1, ë†’ì„ìˆ˜ë¡ ìœ ì‚¬)
        """

        def pointmap_to_voxel(pointmap, grid_size):

            indices = np.array(list(pointmap.keys()))
            coords = np.array(list(pointmap.values()))

            # index ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ì¼ê´€ì„± í™•ë³´
            sorted_indices = sorted(indices)
            coords = np.array([pointmap[idx] for idx in sorted_indices])

            if len(coords) == 0:
                return np.zeros((grid_size, grid_size, grid_size))

            # ì¢Œí‘œ ì •ê·œí™” (0~grid_size-1 ë²”ìœ„ë¡œ)
            min_coords = np.min(coords, axis=0)
            max_coords = np.max(coords, axis=0)
            range_coords = max_coords - min_coords
            range_coords[range_coords == 0] = 1  # 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€

            normalized_coords = (coords - min_coords) / range_coords * (grid_size - 1)
            normalized_coords = np.round(normalized_coords).astype(int)

            # Voxel grid ìƒì„±
            voxel_grid = np.zeros((grid_size, grid_size, grid_size))
            for coord in normalized_coords:
                x, y, z = coord
                voxel_grid[x, y, z] = 1

            return voxel_grid

        try:
            gt_voxel = pointmap_to_voxel(self.teacher_pointmap, grid_size)
            pred_voxel = pointmap_to_voxel(self.student_pointmap, grid_size)

            # 3D SSIM ê³„ì‚° (ê° ìŠ¬ë¼ì´ìŠ¤ë³„ SSIMì˜ í‰ê· )
            ssim_scores = []
            for i in range(grid_size):
                if np.sum(gt_voxel[i]) > 0 or np.sum(pred_voxel[i]) > 0:
                    score = ssim(gt_voxel[i], pred_voxel[i], data_range=1.0)
                    ssim_scores.append(score)

            return float(np.mean(ssim_scores)) if ssim_scores else 0.0

        except Exception as e:
            warnings.warn(f"SSIM ê³„ì‚° ì¤‘ ì˜¤ë¥˜: {e}")
            return 0.0

    def evaluate_all(self, teacher_output: Dict, student_output: Dict) -> Dict:
        """
        ëª¨ë“  ë©”íŠ¸ë¦­ì„ í•œë²ˆì— ê³„ì‚°

        Args:
            teacher_output: Fast3R (Teacher) ëª¨ë¸ì˜ ì¶œë ¥
            student_output: ShowRoom (Student) ëª¨ë¸ì˜ ì¶œë ¥

        Returns:
            Dict: ëª¨ë“  í‰ê°€ ë©”íŠ¸ë¦­ ê²°ê³¼
        """
        results = {}

        print("ğŸ” ì§€ì‹ì¦ë¥˜ í‰ê°€ ì‹œì‘...")

        # 1. Chamber Distance
        print("ğŸ”„ Chamber Distance ê³„ì‚° ì¤‘...")
        results['chamber_distance'] = self.chamber_distance()

        # 2. Point-wise L2 Distance
        print("ğŸ“ Point-wise L2 Distance ê³„ì‚° ì¤‘...")
        results['pointwise_l2'] = self.pointwise_l2_distance()

        # 3. Per-axis MAE
        print("ğŸ“Š Per-axis MAE ê³„ì‚° ì¤‘...")
        results['per_axis_mae'] = self.per_axis_mae()

        # 4. Self-consistency
        print("ğŸ” Self-consistency ê³„ì‚° ì¤‘...")
        results['self_consistency'] = self.self_consistency_check()

        # 5. 3D SSIM
        print("ğŸ–¼ï¸ 3D SSIM ê³„ì‚° ì¤‘...")
        results['ssim_3d'] = self.compute_ssim_3d()

        print("âœ… ëª¨ë“  í‰ê°€ ì™„ë£Œ!")

        return results

    def print_summary(self, results: Dict):
        """
        í‰ê°€ ê²°ê³¼ ìš”ì•½ ì¶œë ¥
        
        Args:
            results: evaluate_all()ì˜ ì¶œë ¥ ê²°ê³¼
        """
        print("\n" + "="*60)
        print("ğŸ“‹ Knowledge Distillation Evaluation Summary")
        print("="*60)
        
        # 1. Chamber Distance
        chamber = results['chamber_distance']
        print(f"\nğŸ”„ Chamber Distance (êµ¬ì¡°ì  ìœ ì‚¬ë„):")
        print(f"   â€¢ ì´ Chamber Distance: {chamber['chamber_distance']:.6f}")
        print(f"   â€¢ GTâ†’Pred: {chamber['cd_gt_to_pred']:.6f}")
        print(f"   â€¢ Predâ†’GT: {chamber['cd_pred_to_gt']:.6f}")
        print(f"   â€¢ GT/Pred í¬ì¸íŠ¸ ìˆ˜: {chamber['num_gt_points']} / {chamber['num_pred_points']}")

        # 2. Point-wise L2 Distance
        l2 = results['pointwise_l2']
        print("\nğŸ“ Point-wise L2 Distance:")
        print(f"   â€¢ í‰ê·  ê±°ë¦¬: {l2['mean_l2_distance']:.6f}")
        print(f"   â€¢ í‘œì¤€ í¸ì°¨: {l2['std_l2_distance']:.6f}")
        print(f"   â€¢ ìµœì†Œ ê±°ë¦¬: {l2['min_l2_distance']:.6f}")
        print(f"   â€¢ ìµœëŒ€ ê±°ë¦¬: {l2['max_l2_distance']:.6f}")
        print(f"   â€¢ ì¤‘ì•™ê°’ ê±°ë¦¬: {l2['median_l2_distance']:.6f}")

        # 3. Per-axis MAE
        mae = results['per_axis_mae']
        print(f"\nğŸ“Š Per-axis MAE (ì¶•ë³„ ì •í™•ë„):")
        print(f"   â€¢ Xì¶• MAE: {mae['mae_x']:.6f}")
        print(f"   â€¢ Yì¶• MAE: {mae['mae_y']:.6f}")
        print(f"   â€¢ Zì¶• MAE: {mae['mae_z']:.6f}")
        print(f"   â€¢ ì „ì²´ MAE: {mae['overall_mae']:.6f}")
        print(f"   â€¢ ìµœëŒ€/ìµœì†Œ ì¶• MAE: {mae['max_axis_mae']:.6f} / {mae['min_axis_mae']:.6f}")
        
        # 4. Self-consistency
        consistency = results['self_consistency']
        print(f"\nğŸ” Self-consistency (ë‚´ë¶€ ì¼ê´€ì„±):")
        print(f"   â€¢ ì¼ê´€ì„± ì ìˆ˜: {consistency['self_consistency_score']:.4f}")
        print(f"   â€¢ Outlier ìˆ˜: {consistency['num_outliers']}")
        print(f"   â€¢ í‰ê·  ì´ì›ƒ ìˆ˜: {consistency['mean_neighbors']:.2f}")
        
        # 5. 3D SSIM
        ssim_score = results['ssim_3d']
        print(f"\nğŸ–¼ï¸ 3D SSIM (êµ¬ì¡°ì  ìœ ì‚¬ì„±):")
        print(f"   â€¢ SSIM ì ìˆ˜: {ssim_score:.4f}")
        
def accuary(teacher_path, student_path):

    # í‰ê°€ ê°ì²´ ìƒì„± ë° ì‹¤í–‰
    evaluator = Evaluator(student_path, teacher_path)
    results = evaluator.evaluate_all(evaluator.teacher_pointmap, evaluator.student_pointmap)
    evaluator.print_summary(results)

    return results

# ì‹¤í–‰
if __name__ == "__main__":
    teacher_path = "/content/drive/MyDrive/ex_teacher_output.pt"
    student_path = "/content/drive/MyDrive/ex_student_output.pth"
    res_accuary = accuary(teacher_path, student_path)

